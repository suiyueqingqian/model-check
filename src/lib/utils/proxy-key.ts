// Proxy API Key management
// Supports multiple keys: environment variable, auto-generated, and database-stored keys

import { randomBytes } from "crypto";
import prisma from "@/lib/prisma";
import type { ProxyKey } from "@/generated/prisma";

// Environment variable key
const ENV_PROXY_API_KEY = process.env.PROXY_API_KEY;

// Auto-generated key (persists for the lifetime of the process)
let generatedKey: string | null = null;

/**
 * Safely parse JSON field as string array
 * Returns null if the value is not a valid string array
 */
function parseStringArray(value: unknown): string[] | null {
  if (value === null || value === undefined) {
    return null;
  }
  if (Array.isArray(value) && value.every((item) => typeof item === "string")) {
    return value as string[];
  }
  // Log warning for invalid data
  return null;
}

/**
 * Generate a random API key in sk-xxx format
 */
export function generateApiKey(): string {
  // Generate 32 random bytes and convert to base64, then clean up
  const randomPart = randomBytes(32)
    .toString("base64")
    .replace(/[+/=]/g, "") // Remove non-URL-safe characters
    .substring(0, 48); // Take first 48 chars
  return `sk-${randomPart}`;
}

/**
 * Get the proxy API key (legacy - returns env or auto-generated key)
 * - If PROXY_API_KEY env is set, use it
 * - Otherwise, auto-generate one (persists for process lifetime)
 */
export function getProxyApiKey(): string {
  if (ENV_PROXY_API_KEY) {
    return ENV_PROXY_API_KEY;
  }

  if (!generatedKey) {
    generatedKey = generateApiKey();
  }

  return generatedKey;
}

/**
 * Check if the key was auto-generated or from environment
 */
export function isKeyFromEnvironment(): boolean {
  return !!ENV_PROXY_API_KEY;
}

/**
 * Validate API key result
 */
export interface ValidateKeyResult {
  valid: boolean;
  keyRecord?: ProxyKey;
  isEnvKey?: boolean;
  isAutoGenerated?: boolean;
}

/**
 * Validate a proxy API key
 * Priority: Environment variable > Database keys > Auto-generated key
 */
export async function validateProxyKey(apiKey: string): Promise<ValidateKeyResult> {
  // 1. Check environment variable key first
  if (ENV_PROXY_API_KEY && apiKey === ENV_PROXY_API_KEY) {
    return { valid: true, isEnvKey: true };
  }

  // 2. Check database keys
  try {
    const keyRecord = await prisma.proxyKey.findUnique({
      where: { key: apiKey },
    });

    if (keyRecord) {
      if (!keyRecord.enabled) {
        return { valid: false };
      }

      // Update usage statistics in background (don't block or fail on error)
      prisma.proxyKey.update({
        where: { id: keyRecord.id },
        data: {
          lastUsedAt: new Date(),
          usageCount: { increment: 1 },
        },
      }).catch((error) => {
      });

      return { valid: true, keyRecord };
    }
  } catch (error) {
    // Fall through to check auto-generated key
  }

  // 3. Check auto-generated key (fallback when no env key is set)
  if (!ENV_PROXY_API_KEY) {
    const autoKey = getProxyApiKey();
    if (apiKey === autoKey) {
      return { valid: true, isAutoGenerated: true };
    }
  }

  return { valid: false };
}

/**
 * Check if a key has permission to access a specific model
 * @param keyRecord - The proxy key record (undefined for env/auto-generated keys)
 * @param isEnvKey - Whether the key is from environment variable
 * @param channelId - The channel ID
 * @param modelId - The model ID
 * @param modelStatus - The model's last test status (true = healthy, false = unhealthy, null = untested)
 */
export async function canAccessModel(
  keyRecord: ProxyKey | undefined,
  isEnvKey: boolean | undefined,
  channelId: string,
  modelId: string,
  modelStatus: boolean | null
): Promise<boolean> {
  // Environment key and auto-generated key have full access
  if (isEnvKey) {
    return true;
  }

  // No key record means auto-generated key (full access)
  if (!keyRecord) {
    return true;
  }

  // If key allows all models, check model status
  if (keyRecord.allowAllModels) {
    // Only explicitly healthy models can be accessed.
    return modelStatus === true;
  }

  // allowAllModels=false: only explicitly specified channels/models are allowed
  // Permission logic: channel match OR model match grants access
  const allowedChannelIds = parseStringArray(keyRecord.allowedChannelIds);
  const allowedModelIds = parseStringArray(keyRecord.allowedModelIds);

  // If no explicit permissions configured, deny all
  const hasChannelPerms = allowedChannelIds !== null && allowedChannelIds.length > 0;
  const hasModelPerms = allowedModelIds !== null && allowedModelIds.length > 0;

  if (!hasChannelPerms && !hasModelPerms) {
    return false;
  }

  // Grant access if channel OR model is in the allowed list
  if (hasChannelPerms && allowedChannelIds.includes(channelId)) {
    return true;
  }
  if (hasModelPerms && allowedModelIds.includes(modelId)) {
    return true;
  }

  return false;
}

/**
 * Get available models for a key
 * Returns a list of model IDs that the key can access
 */
export async function getAccessibleModels(keyRecord: ProxyKey | undefined, isEnvKey: boolean | undefined): Promise<{
  allModels: boolean;
  channelIds?: string[];
  modelIds?: string[];
}> {
  // Environment key and auto-generated key have full access
  if (isEnvKey || !keyRecord) {
    return { allModels: true };
  }

  if (keyRecord.allowAllModels) {
    return { allModels: true };
  }

  return {
    allModels: false,
    channelIds: parseStringArray(keyRecord.allowedChannelIds) ?? undefined,
    modelIds: parseStringArray(keyRecord.allowedModelIds) ?? undefined,
  };
}
